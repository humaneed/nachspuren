<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="theme-color" content="#D4A574" />
  <meta name="description" content="Alphabet nachspuren ‚Äì Buchstaben einzeln als Aufgabe (Kl. 1‚Äì4)" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <title>Alphabet ‚Äì Nachspuren</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@600;800;900&display=swap" rel="stylesheet">

  <style>
    :root{
      --s-1: 8px; --s-2: 16px; --s-3: 24px; --s-4: 32px;
      --bg-canvas: #F5F0E8;
      --bg-card: #FFFFFF;
      --bg-muted: #EDE8DC;
      --ink: #2D2A26;
      --muted: #6B665C;
      --accent: #D4A574;
      --good: #7BA08A;
      --bad: #C4726C;
      --r-lg: 24px;
      --r-xl: 28px;
      --shadow: 0 2px 10px rgba(45,42,38,.10);
      --shadow2: 0 1px 3px rgba(45,42,38,.06);
      --font: 'Nunito', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      --app-max-w: 600px;
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html, body{ height:100%; }
    body{
      margin:0;
      background: var(--bg-canvas);
      color: var(--ink);
      font-family: var(--font);
      font-weight: 800;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
    }
    *:focus-visible{ outline: 3px solid var(--accent); outline-offset: 2px; border-radius: 12px; }

    #app{
      width:100%;
      height:100%;
      background: var(--bg-card);
      display:flex;
      flex-direction:column;
      overflow:hidden;
      position:relative;
    }
    @media (min-width: 520px){
      body{ padding: var(--s-3); }
      #app{
        max-width: var(--app-max-w);
        height: 94dvh;
        max-height: 940px;
        border: 3px solid var(--ink);
        border-radius: var(--r-lg);
        box-shadow: var(--shadow2);
      }
    }

    header{
      height: 72px;
      padding: 0 var(--s-3);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: var(--s-2);
      border-bottom: 3px solid var(--ink);
      background: var(--bg-card);
      flex: 0 0 auto;
    }
    .brand{ display:flex; flex-direction:column; gap:2px; min-width:0; }
    .title{ font-size: 20px; font-weight: 900; letter-spacing:-.02em; line-height:1.1; }
    .subtitle{ font-size: 12px; font-weight: 900; letter-spacing:.10em; text-transform:uppercase; color: var(--muted); }
    .top-actions{ display:flex; gap: var(--s-2); align-items:center; }

    .pill{
      min-height: 48px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 2px solid var(--ink);
      background: var(--bg-muted);
      display:flex;
      align-items:center;
      gap: 8px;
      user-select:none;
      cursor:pointer;
      transition: transform 150ms ease, box-shadow 150ms ease;
    }
    .pill:hover{ box-shadow: var(--shadow); transform: translateY(-1px); }
    .pill:active{ transform: scale(.98); box-shadow:none; }
    .pill .icon{ font-size:18px; }
    .pill .val{ font-weight: 900; font-size: 14px; }

    main{
      flex:1;
      overflow:auto;
      padding: var(--s-3);
      background:
        radial-gradient(1200px 340px at 50% 0%, rgba(212,165,116,.14), transparent 60%),
        var(--bg-card);
      overscroll-behavior: contain;
      -webkit-overflow-scrolling: touch;
    }

    .hero{
      border: 3px solid var(--ink);
      border-radius: var(--r-xl);
      padding: var(--s-3);
      background: linear-gradient(180deg, rgba(237,232,220,.55), rgba(255,255,255,1));
      box-shadow: var(--shadow2);
      margin-bottom: var(--s-3);
    }
    .hero h1{ margin:0 0 6px; font-size: 24px; font-weight: 900; letter-spacing:-.02em; }
    .hero p{ margin:0; font-size: 14px; font-weight: 800; color: var(--muted); }

    .card{
      border: 3px solid var(--ink);
      border-radius: var(--r-xl);
      background: var(--bg-card);
      box-shadow: var(--shadow2);
      padding: var(--s-3);
    }

    .row{ display:flex; flex-wrap:wrap; gap: var(--s-2); align-items:center; justify-content:space-between; }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 2px solid var(--ink);
      background: var(--bg-muted);
      font-size: 12px;
      font-weight: 900;
      letter-spacing:.08em;
      text-transform:uppercase;
      user-select:none;
    }

    .progress{
      width:100%;
      height: 14px;
      border-radius: 999px;
      border: 2px solid var(--ink);
      background: rgba(0,0,0,0.04);
      overflow:hidden;
    }
    .progress > div{
      height:100%;
      width:0%;
      background: rgba(212,165,116,.75);
      transition: width 260ms ease;
    }

    .stage{
      margin-top: var(--s-2);
      border-radius: 18px;
      border: 3px solid var(--ink);
      background: var(--bg-card);
      box-shadow: var(--shadow2);
      overflow:hidden;
    }
    .stage-head{
      padding: 12px 14px;
      border-bottom: 3px solid var(--ink);
      background: rgba(237,232,220,.55);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: var(--s-2);
      flex-wrap: wrap;
    }
    .big-letter{
      font-size: 22px;
      font-weight: 900;
      letter-spacing:-.02em;
    }
    .mini{ font-size: 12px; font-weight: 900; color: var(--muted); letter-spacing:.10em; text-transform:uppercase; }

    .canvas-wrap{
      position: relative;
      width: 100%;
      background: #fff;
      touch-action: none;
    }
    canvas{ display:block; width:100%; height:auto; }
    #bgCanvas{ position: relative; z-index: 1; }
    #drawCanvas{
      position:absolute;
      inset: 0;
      z-index: 2;
    }

    .controls{
      margin-top: var(--s-2);
      display:grid;
      gap: var(--s-2);
    }
    .controls-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--s-2);
    }
    .ctrl{
      border: 2px solid var(--ink);
      border-radius: 16px;
      padding: 12px;
      background: rgba(0,0,0,0.02);
    }
    .ctrl label{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      font-weight: 900;
      font-size: 12px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color: var(--muted);
      margin-bottom: 8px;
    }
    input[type="range"]{ width:100%; }
    .swatches{ display:flex; gap:10px; flex-wrap:wrap; }
    .sw{
      width: 44px; height: 36px;
      border-radius: 12px;
      border: 2px solid var(--ink);
      background: var(--bg-muted);
      cursor:pointer;
      user-select:none;
    }
    .sw[data-on="1"]{ outline: 3px solid var(--accent); outline-offset: 2px; }

    .actions{
      display:flex;
      flex-wrap:wrap;
      gap: var(--s-2);
      margin-top: var(--s-2);
    }
    .btn{
      min-height: 48px;
      padding: 12px 14px;
      border-radius: 12px;
      border: 2px solid var(--ink);
      background: var(--bg-card);
      color: var(--muted);
      font-family: var(--font);
      font-weight: 900;
      font-size: 14px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap: 8px;
      user-select:none;
      transition: transform 150ms ease, box-shadow 150ms ease, filter 150ms ease;
      flex: 1 1 calc(50% - var(--s-2));
    }
    .btn:hover{ box-shadow: var(--shadow); transform: translateY(-1px); }
    .btn:active{ transform: translateY(1px); box-shadow:none; }
    .btn.primary{ background: var(--accent); color: var(--bg-card); }
    .btn.primary:hover{ filter: brightness(1.05); }
    .btn.good{ background: rgba(123,160,138,.16); color: var(--ink); }
    .btn.bad{ background: rgba(196,114,108,.12); color: var(--ink); }

    .feedback{
      margin-top: var(--s-2);
      padding: 12px 14px;
      border-radius: 12px;
      border: 2px solid var(--ink);
      background: var(--bg-muted);
      display:none;
      gap: 10px;
      align-items:flex-start;
    }
    .feedback.open{ display:flex; }
    .ficon{ font-size: 18px; line-height:1.2; }
    .ftext{ font-size: 14px; font-weight: 900; color: var(--muted); }
    .ftext strong{ color: var(--ink); }

    footer{
      flex: 0 0 auto;
      padding: var(--s-2) var(--s-3);
      padding-bottom: max(var(--s-2), env(safe-area-inset-bottom));
      border-top: 3px solid var(--ink);
      background: var(--bg-card);
      display:flex;
      flex-wrap:wrap;
      gap: var(--s-2);
    }
    .btn-small{
      min-height: 48px;
      padding: 12px 14px;
      border-radius: 12px;
      border: 2px solid var(--ink);
      background: var(--bg-muted);
      color: var(--muted);
      font-family: var(--font);
      font-weight: 900;
      font-size: 14px;
      cursor:pointer;
      flex: 1 1 calc(33.33% - var(--s-2));
    }
    .btn-small.primary{ background: var(--accent); color: var(--bg-card); }
    .btn-small:hover{ box-shadow: var(--shadow); transform: translateY(-1px); }
    .btn-small:active{ transform: translateY(1px); box-shadow:none; }

    @media (max-width: 360px){
      header{ padding: 0 var(--s-2); }
      main{ padding: var(--s-2); }
      footer{ padding: var(--s-2); }
      .controls-grid{ grid-template-columns: 1fr; }
    }
  </style>
</head>

<body>
  <div id="app">
    <header>
      <div class="brand">
        <div class="title">Alphabet ‚Äì Nachspuren</div>
        <div class="subtitle">Ein Buchstabe pro Aufgabe ¬∑ wie Paint</div>
      </div>
      <div class="top-actions">
        <div class="pill" id="coins-pill" role="button" tabindex="0" aria-label="Punkte">
          <span class="icon">‚≠ê</span>
          <span class="val" id="coin-count">0</span>
        </div>
        <div class="pill" id="help-pill" role="button" tabindex="0" aria-label="Tipp">
          <span class="icon">üí°</span>
          <span class="val">Tipp</span>
        </div>
      </div>
    </header>

    <main>
      <div class="hero">
        <h1>Spur den Buchstaben nach.</h1>
        <p>Mit ‚ÄûVorlage‚Äú kannst du das Bild heller/dunkler machen. Radierer = Fehler weg. ‚≠ê gibt‚Äôs f√ºr gutes Nachspuren.</p>
      </div>

      <section class="card">
        <div class="row">
          <div class="chip" id="task-chip">üî§ Buchstabe: ‚Ä¶</div>
          <div class="chip">üìå Fortschritt: <span id="prog-text">0/30</span></div>
        </div>

        <div style="margin-top:12px;">
          <div class="progress" aria-label="Fortschrittsbalken">
            <div id="prog-bar"></div>
          </div>
        </div>

        <div class="stage" style="margin-top:16px;">
          <div class="stage-head">
            <div>
              <div class="big-letter" id="big-letter">‚Ä¶</div>
              <div class="mini" id="mini-hint">Spur nach: langsam & sauber</div>
            </div>
            <div class="mini">Score: <span id="score">‚Äì</span></div>
          </div>

          <div class="canvas-wrap" id="canvas-wrap">
            <canvas id="bgCanvas"></canvas>
            <canvas id="drawCanvas"></canvas>
          </div>
        </div>

        <div class="controls">
          <div class="controls-grid">
            <div class="ctrl">
              <label>
                <span>üñåÔ∏è Pinsel</span>
                <span id="brushVal">18</span>
              </label>
              <input id="brush" type="range" min="6" max="34" value="18" />
              <div style="display:flex; gap:10px; margin-top:10px; flex-wrap:wrap;">
                <button class="btn good" id="eraser" type="button" style="flex:1 1 auto;">üßΩ Radierer: <span id="eraserOn">Aus</span></button>
                <button class="btn" id="undo" type="button" style="flex:1 1 auto;">‚Ü©Ô∏è Undo</button>
              </div>
            </div>

            <div class="ctrl">
              <label>
                <span>üßæ Vorlage</span>
                <span id="tplVal">75%</span>
              </label>
              <input id="tpl" type="range" min="15" max="100" value="75" />
              <div class="swatches" style="margin-top:10px;">
                <div class="sw" data-color="#1f2a2e" data-on="1" title="Dunkel"></div>
                <div class="sw" data-color="#2f6fa1" title="Blau"></div>
                <div class="sw" data-color="#c4726c" title="Rot"></div>
                <div class="sw" data-color="#2f9e6f" title="Gr√ºn"></div>
                <div class="sw" data-color="#222222" title="Schwarz"></div>
              </div>
            </div>
          </div>

          <div class="actions">
            <button class="btn" id="prev" type="button">‚¨ÖÔ∏è Zur√ºck</button>
            <button class="btn" id="next" type="button">Weiter ‚û°Ô∏è</button>
            <button class="btn" id="random" type="button">üé≤ Zufall</button>
            <button class="btn bad" id="clear" type="button">üßº Neu</button>
            <button class="btn primary" id="check" type="button">‚úÖ Pr√ºfen</button>
            <button class="btn good" id="markDone" type="button">‚≠ê Fertig</button>
          </div>

          <div class="feedback" id="fb" aria-live="polite">
            <div class="ficon" id="fbI">‚ú®</div>
            <div class="ftext" id="fbT"><strong>‚Ä¶</strong></div>
          </div>

          <div class="mini" style="margin-top:10px;">
            Vorlage-Datei: <strong>abcnachspuren.jpg</strong> (muss im selben Ordner liegen)
          </div>
        </div>
      </section>
    </main>

    <footer>
      <button class="btn-small" id="btn-home" type="button" title="Zur√ºck">01</button>
      <button class="btn-small" id="reload" type="button" title="Neu laden">‚èª</button>
      <a class="btn-small primary" href="https://humaneed.github.io/Datenschutz/" target="_blank" rel="noopener noreferrer" style="text-decoration:none; display:flex; align-items:center; justify-content:center;">
        üîí Datenschutz
      </a>
    </footer>
  </div>

  <!-- Hidden template image -->
  <img id="tplImg" alt="" style="display:none" />

  <script>
    (() => {
      'use strict';

      const $ = (s) => document.querySelector(s);
      const $$ = (s) => Array.from(document.querySelectorAll(s));

      // ===== Shared LS (Kidsneed) =====
      const LS = {
        coins: 'kidsneed_coins',
        done:  'kidsneed_alpha_trace_done',
        idx:   'kidsneed_alpha_trace_idx'
      };

      const getInt = (k, fb=0) => {
        try { const v = localStorage.getItem(k); const n = v ? parseInt(v,10) : fb; return Number.isFinite(n) ? n : fb; }
        catch { return fb; }
      };
      const setStr = (k,v) => { try { localStorage.setItem(k, String(v)); } catch {} };
      const getObj = (k, fb) => {
        try { const raw = localStorage.getItem(k); return raw ? (JSON.parse(raw) ?? fb) : fb; }
        catch { return fb; }
      };
      const setObj = (k,v) => { try { localStorage.setItem(k, JSON.stringify(v)); } catch {} };

      const bump = (el) => {
        if (!el) return;
        el.style.transform = 'scale(1.08)';
        setTimeout(() => el.style.transform = '', 160);
      };

      // ===== Home button =====
      const computeHomeHref = () => {
        const p = location.pathname;
        if (p.includes('/ueben/alphabet-nachspuren/')) return '../../';
        return '/';
      };

      // ===== Tasks: Boxes (aus deinem Bild erkannt) =====
      // Box = [x0,y0,x1,y1] im Originalbild (1069x1500).
      const TASKS = [
        { id:'Aa', label:'A a', box:[37,220,203,358] },
        { id:'Bb', label:'B b', box:[245,220,406,358] },
        { id:'Cc', label:'C c', box:[447,220,608,358] },
        { id:'Dd', label:'D d', box:[652,220,824,358] },
        { id:'Ee', label:'E e', box:[866,220,1019,358] },

        { id:'Ff', label:'F f', box:[39,428,175,582] },
        { id:'Gg', label:'G g', box:[236,428,407,582] },
        { id:'Hh', label:'H h', box:[445,428,604,582] },
        { id:'Ii', label:'I i', box:[699,428,781,582] },
        { id:'Jj', label:'J j', box:[893,428,995,582] },

        { id:'Kk', label:'K k', box:[40,636,190,774] },
        { id:'Ll', label:'L l', box:[241,636,366,774] },
        { id:'Mm', label:'M m', box:[416,636,639,774] },
        { id:'Nn', label:'N n', box:[654,636,822,774] },
        { id:'Oo', label:'O o', box:[859,636,1035,774] },

        { id:'Pp', label:'P p', box:[41,844,196,983] },
        { id:'Qq', label:'Q q', box:[241,844,409,983] },
        { id:'Rr', label:'R r', box:[452,844,578,983] },
        { id:'Ss', label:'S s', box:[668,844,808,983] },
        { id:'Tt', label:'T t', box:[875,844,1005,983] },

        { id:'Uu', label:'U u', box:[0,1051,201,1191] },
        { id:'Vv', label:'V v', box:[235,1051,402,1191] },
        { id:'Ww', label:'W w', box:[421,1051,637,1191] },
        { id:'Xx', label:'X x', box:[667,1051,811,1191] },
        { id:'Yy', label:'Y y', box:[878,1051,1014,1191] },

        { id:'Zz', label:'Z z', box:[39,1254,197,1400] },
        { id:'√Ñ√§', label:'√Ñ √§', box:[247,1254,403,1400] },
        { id:'√ñ√∂', label:'√ñ √∂', box:[444,1254,618,1400] },
        { id:'√ú√º', label:'√ú √º', box:[656,1254,826,1400] },
        { id:'√ü',  label:'√ü',   box:[905,1254,993,1400] },
      ];

      // ===== UI =====
      const coinsPill = $('#coins-pill');
      const coinCount = $('#coin-count');
      const taskChip = $('#task-chip');
      const bigLetter = $('#big-letter');
      const miniHint  = $('#mini-hint');
      const scoreEl   = $('#score');
      const fb = $('#fb');
      const fbI = $('#fbI');
      const fbT = $('#fbT');
      const progText = $('#prog-text');
      const progBar  = $('#prog-bar');

      const brush = $('#brush');
      const brushVal = $('#brushVal');
      const tpl = $('#tpl');
      const tplVal = $('#tplVal');
      const eraserBtn = $('#eraser');
      const eraserOn = $('#eraserOn');

      const prevBtn = $('#prev');
      const nextBtn = $('#next');
      const rndBtn  = $('#random');
      const clearBtn= $('#clear');
      const undoBtn = $('#undo');
      const checkBtn= $('#check');
      const doneBtn = $('#markDone');
      const helpPill= $('#help-pill');

      const bgCanvas = $('#bgCanvas');
      const drawCanvas = $('#drawCanvas');
      const wrap = $('#canvas-wrap');
      const bgCtx = bgCanvas.getContext('2d', { willReadFrequently: true });
      const drawCtx = drawCanvas.getContext('2d', { willReadFrequently: true });

      // ===== State =====
      let idx = Math.max(0, Math.min(TASKS.length-1, getInt(LS.idx, 0)));
      let doneSet = new Set(getObj(LS.done, []));
      let isEraser = false;

      let dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      let painting = false;
      let last = null;
      let undoStack = []; // ImageData snapshots (limited)
      const UNDO_MAX = 12;

      let templateImg = $('#tplImg');
      let maskData = null; // Uint8Array, mw*mh
      let maskW = 0, maskH = 0;

      const showFeedback = (icon, html) => {
        fbI.textContent = icon;
        fbT.innerHTML = html;
        fb.classList.add('open');
      };
      const closeFeedback = () => fb.classList.remove('open');

      const updateCoins = () => {
        coinCount.textContent = getInt(LS.coins, 0);
      };
      const addCoin = (n=1) => {
        const c = getInt(LS.coins, 0) + n;
        setStr(LS.coins, c);
        updateCoins();
        bump(coinsPill);
      };

      const updateProgress = () => {
        const doneCount = doneSet.size;
        progText.textContent = `${doneCount}/${TASKS.length}`;
        progBar.style.width = `${Math.round((doneCount / TASKS.length) * 100)}%`;
      };

      // ===== Canvas sizing =====
      const fitCanvas = () => {
        // Stage should be 16:9-ish but adapt
        const w = wrap.clientWidth;
        const h = Math.max(280, Math.min(420, Math.round(w * 0.66))); // pleasant
        bgCanvas.style.height = h + 'px';
        drawCanvas.style.height = h + 'px';
        bgCanvas.width = Math.round(w * dpr);
        bgCanvas.height = Math.round(h * dpr);
        drawCanvas.width = Math.round(w * dpr);
        drawCanvas.height = Math.round(h * dpr);
      };

      // ===== Render current task (crop from template image) =====
      const renderTask = () => {
        const t = TASKS[idx];

        setStr(LS.idx, idx);

        taskChip.textContent = `üî§ Buchstabe: ${t.label}`;
        bigLetter.textContent = t.label;
        miniHint.textContent = doneSet.has(t.id)
          ? '‚úÖ Schon geschafft ‚Äì du kannst nochmal √ºben!'
          : 'Spur nach: langsam, saubere Linien, lieber einmal richtig';

        closeFeedback();
        scoreEl.textContent = '‚Äì';

        // reset drawing
        clearDrawing(true);

        // draw crop into bg canvas
        fitCanvas();

        const [x0,y0,x1,y1] = t.box;
        const sw = (x1-x0), sh = (y1-y0);

        bgCtx.save();
        bgCtx.setTransform(1,0,0,1,0,0);
        bgCtx.clearRect(0,0,bgCanvas.width,bgCanvas.height);

        // background fill
        bgCtx.fillStyle = '#ffffff';
        bgCtx.fillRect(0,0,bgCanvas.width,bgCanvas.height);

        // scale crop to fit canvas (with padding)
        const pad = 16 * dpr;
        const cw = bgCanvas.width, ch = bgCanvas.height;
        const availW = cw - pad*2;
        const availH = ch - pad*2;
        const scale = Math.min(availW/sw, availH/sh);

        const dw = sw * scale;
        const dh = sh * scale;
        const dx = (cw - dw)/2;
        const dy = (ch - dh)/2;

        // Apply template opacity via global alpha
        const alpha = (parseInt(tpl.value,10) || 75) / 100;
        bgCtx.globalAlpha = alpha;

        bgCtx.imageSmoothingEnabled = true;
        bgCtx.imageSmoothingQuality = 'high';

        // draw the cropped portion
        bgCtx.drawImage(templateImg, x0, y0, sw, sh, dx, dy, dw, dh);

        // overlay a subtle frame
        bgCtx.globalAlpha = 1;
        bgCtx.lineWidth = 2 * dpr;
        bgCtx.strokeStyle = 'rgba(45,42,38,.20)';
        bgCtx.strokeRect(dx, dy, dw, dh);

        bgCtx.restore();

        // build letter mask for scoring (from same crop)
        buildMaskFromCrop(x0,y0,sw,sh, dx,dy,dw,dh);
      };

      // ===== Build mask for scoring =====
      // We create a downscaled mask (256x256-ish) based on the crop pixels (notebook lines should be ignored).
      const buildMaskFromCrop = (x0,y0,sw,sh, dx,dy,dw,dh) => {
        const mw = 256;
        const mh = 256;
        maskW = mw; maskH = mh;
        const off = document.createElement('canvas');
        off.width = mw; off.height = mh;
        const oc = off.getContext('2d', { willReadFrequently: true });

        // draw crop into offscreen
        oc.clearRect(0,0,mw,mh);
        oc.drawImage(templateImg, x0, y0, sw, sh, 0, 0, mw, mh);

        const imgd = oc.getImageData(0,0,mw,mh).data;
        const m = new Uint8Array(mw*mh);

        // threshold: letters are darker/colored than paper lines
        for (let i=0, p=0; i<imgd.length; i+=4, p++){
          const r = imgd[i], g = imgd[i+1], b = imgd[i+2];
          const max = Math.max(r,g,b);
          const min = Math.min(r,g,b);
          const sat = max - min;
          const br = (r+g+b)/3;

          // letter pixel heuristic:
          // - either sufficiently saturated OR sufficiently dark
          // - and not near-white
          const isLetter = (br < 222) || (sat > 22 && br < 246);

          m[p] = isLetter ? 1 : 0;
        }

        // small dilation for tolerance
        const dil = new Uint8Array(mw*mh);
        const rad = 2;
        for (let y=0; y<mh; y++){
          for (let x=0; x<mw; x++){
            let on = 0;
            for (let yy=Math.max(0,y-rad); yy<=Math.min(mh-1,y+rad) && !on; yy++){
              for (let xx=Math.max(0,x-rad); xx<=Math.min(mw-1,x+rad); xx++){
                if (m[yy*mw + xx]) { on = 1; break; }
              }
            }
            dil[y*mw + x] = on;
          }
        }

        // store
        maskData = dil;

        // store mapping to screen area for scoring
        // We score using the drawn canvas area that corresponds to the crop area.
        // We can recompute mapping when scoring by finding where crop sits: we already use dx,dy,dw,dh.
        // Store for current task:
        TASKS[idx]._map = { dx, dy, dw, dh };
      };

      // ===== Drawing =====
      const pushUndo = () => {
        try{
          const snap = drawCtx.getImageData(0,0,drawCanvas.width, drawCanvas.height);
          undoStack.push(snap);
          if (undoStack.length > UNDO_MAX) undoStack.shift();
        } catch {}
      };

      const clearDrawing = (hard=false) => {
        drawCtx.save();
        drawCtx.setTransform(1,0,0,1,0,0);
        drawCtx.clearRect(0,0,drawCanvas.width, drawCanvas.height);
        drawCtx.restore();
        if (hard) undoStack = [];
        else pushUndo();
      };

      const setBrushStyle = () => {
        const size = parseInt(brush.value,10) || 18;
        brushVal.textContent = size;

        drawCtx.lineCap = 'round';
        drawCtx.lineJoin = 'round';
        drawCtx.lineWidth = size * dpr;

        if (isEraser){
          drawCtx.globalCompositeOperation = 'destination-out';
          drawCtx.strokeStyle = 'rgba(0,0,0,1)';
        } else {
          drawCtx.globalCompositeOperation = 'source-over';
          drawCtx.strokeStyle = currentColor;
        }
      };

      let currentColor = '#1f2a2e';

      const setColorUI = (hex) => {
        currentColor = hex;
        $$('.sw').forEach(sw => sw.dataset.on = (sw.dataset.color === hex ? '1' : '0'));
        if (!isEraser) setBrushStyle();
      };

      const getPos = (e) => {
        const rect = drawCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * dpr;
        const y = (e.clientY - rect.top) * dpr;
        return {x,y};
      };

      const begin = (e) => {
        painting = true;
        last = getPos(e);
        pushUndo();
        setBrushStyle();
        drawCtx.beginPath();
        drawCtx.moveTo(last.x, last.y);
      };
      const move = (e) => {
        if (!painting) return;
        const p = getPos(e);
        drawCtx.lineTo(p.x, p.y);
        drawCtx.stroke();
        last = p;
      };
      const end = () => {
        painting = false;
        last = null;
      };

      // Pointer events
      drawCanvas.addEventListener('pointerdown', (e) => { drawCanvas.setPointerCapture(e.pointerId); begin(e); });
      drawCanvas.addEventListener('pointermove', move);
      drawCanvas.addEventListener('pointerup', end);
      drawCanvas.addEventListener('pointercancel', end);
      drawCanvas.addEventListener('pointerleave', end);

      // ===== Scoring =====
      const scoreNow = () => {
        const t = TASKS[idx];
        if (!maskData || !t._map) {
          showFeedback('‚ö†Ô∏è', `<strong>Noch nicht bereit.</strong> Bild l√§dt noch.`);
          return null;
        }

        // Get drawn pixels in crop area only
        const { dx, dy, dw, dh } = t._map;
        const x0 = Math.max(0, Math.floor(dx));
        const y0 = Math.max(0, Math.floor(dy));
        const x1 = Math.min(drawCanvas.width, Math.ceil(dx+dw));
        const y1 = Math.min(drawCanvas.height, Math.ceil(dy+dh));

        let img;
        try { img = drawCtx.getImageData(x0,y0,x1-x0,y1-y0).data; }
        catch { return null; }

        // Sample drawn pixels (alpha > 0)
        let drawn = 0;
        let hit = 0;

        const w = (x1-x0), h = (y1-y0);
        // step to speed up
        const step = 2;

        for (let y=0; y<h; y+=step){
          for (let x=0; x<w; x+=step){
            const i = (y*w + x) * 4;
            const a = img[i+3];
            if (a > 10){
              drawn++;
              // map to mask coords (mw,mh) based on crop area
              const mx = Math.min(maskW-1, Math.max(0, Math.floor((x / w) * maskW)));
              const my = Math.min(maskH-1, Math.max(0, Math.floor((y / h) * maskH)));
              if (maskData[my*maskW + mx]) hit++;
            }
          }
        }

        if (drawn < 40){
          return { pct: 0, drawn, hit };
        }

        const pct = Math.round((hit / drawn) * 100);
        return { pct, drawn, hit };
      };

      // ===== Done / reward =====
      const markDone = (forced=false) => {
        const t = TASKS[idx];
        const s = scoreNow();

        // if forced, allow mark anyway
        if (!forced && s && s.drawn >= 40 && s.pct < 60){
          showFeedback('üí°', `<strong>Noch nicht.</strong> Dein Treffer ist <strong>${s.pct}%</strong>. Versuch langsam √ºber die Buchstabenform zu malen.`);
          return;
        }

        if (!doneSet.has(t.id)){
          doneSet.add(t.id);
          setObj(LS.done, Array.from(doneSet));
          addCoin(1);
          showFeedback('‚úÖ', `<strong>Geschafft!</strong> ${t.label} gespeichert. ‚≠ê +1`);
        } else {
          showFeedback('‚ú®', `<strong>Super!</strong> ${t.label} nochmal ge√ºbt.`);
        }

        updateProgress();
      };

      // ===== Events =====
      window.addEventListener('resize', () => {
        dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        renderTask();
      });

      brush.addEventListener('input', () => setBrushStyle());

      tpl.addEventListener('input', () => {
        tplVal.textContent = `${tpl.value}%`;
        renderTask();
      });

      eraserBtn.addEventListener('click', () => {
        isEraser = !isEraser;
        eraserOn.textContent = isEraser ? 'An' : 'Aus';
        eraserBtn.classList.toggle('primary', isEraser);
        setBrushStyle();
      });

      undoBtn.addEventListener('click', () => {
        if (!undoStack.length) return;
        const snap = undoStack.pop();
        if (!snap) return;
        drawCtx.putImageData(snap, 0, 0);
      });

      clearBtn.addEventListener('click', () => {
        clearDrawing(false);
        scoreEl.textContent = '‚Äì';
        showFeedback('üßº', `<strong>Neu.</strong> Du kannst nochmal sauber nachspuren.`);
      });

      prevBtn.addEventListener('click', () => {
        idx = (idx - 1 + TASKS.length) % TASKS.length;
        renderTask();
      });

      nextBtn.addEventListener('click', () => {
        idx = (idx + 1) % TASKS.length;
        renderTask();
      });

      rndBtn.addEventListener('click', () => {
        idx = Math.floor(Math.random() * TASKS.length);
        renderTask();
      });

      checkBtn.addEventListener('click', () => {
        const s = scoreNow();
        if (!s){
          showFeedback('‚ö†Ô∏è', `<strong>Geht noch nicht.</strong> Bild l√§dt noch.`);
          return;
        }
        if (s.drawn < 40){
          scoreEl.textContent = '‚Äì';
          showFeedback('üß©', `<strong>Noch fast leer.</strong> Mal erst ein bisschen √ºber den Buchstaben.`);
          return;
        }
        scoreEl.textContent = `${s.pct}%`;
        if (s.pct >= 80){
          showFeedback('üèÜ', `<strong>Sehr gut!</strong> Treffer <strong>${s.pct}%</strong>. Das ist richtig sauber.`);
        } else if (s.pct >= 60){
          showFeedback('‚úÖ', `<strong>Gut!</strong> Treffer <strong>${s.pct}%</strong>. Noch etwas langsamer = noch besser.`);
        } else {
          showFeedback('üí°', `<strong>Weiter √ºben.</strong> Treffer <strong>${s.pct}%</strong>. Versuch die Linie direkt √ºber dem Buchstaben zu halten.`);
        }
      });

      doneBtn.addEventListener('click', () => markDone(false));

      helpPill.addEventListener('click', () => {
        showFeedback('üí°', `<strong>So geht‚Äôs:</strong><br>
          1) Male langsam √ºber die Buchstabenform.<br>
          2) Nutze ‚ÄûVorlage‚Äú, wenn‚Äôs zu dunkel/hell ist.<br>
          3) Radierer an, Fehler weg.<br>
          4) ‚ÄûPr√ºfen‚Äú zeigt deinen Treffer.<br>
          5) ‚ÄûFertig‚Äú speichert + ‚≠ê.`);
        bump(helpPill);
      });

      $$('.sw').forEach(el => {
        el.style.background = el.dataset.color;
        el.addEventListener('click', () => {
          isEraser = false;
          eraserOn.textContent = 'Aus';
          eraserBtn.classList.remove('primary');
          setColorUI(el.dataset.color);
          setBrushStyle();
        });
      });

      $('#reload').addEventListener('click', () => location.reload());
      $('#btn-home').addEventListener('click', () => location.href = computeHomeHref());
      coinsPill.addEventListener('click', () => bump(coinsPill));

      // ===== Load template image =====
      const init = () => {
        updateCoins();
        updateProgress();

        tplVal.textContent = `${tpl.value}%`;
        brushVal.textContent = brush.value;

        setColorUI('#1f2a2e');
        setBrushStyle();

        // load image from same folder
        templateImg.onload = () => renderTask();
        templateImg.onerror = () => {
          showFeedback('‚ö†Ô∏è', `<strong>Bild fehlt.</strong> Lege <strong>abcnachspuren.jpg</strong> in denselben Ordner wie diese index.html.`);
        };
        templateImg.src = './abcnachspuren.jpg';
      };

      init();
    })();
  </script>
</body>
</html>
